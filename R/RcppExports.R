# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Sum of logged probabilities.
#'
#' \code{"logsum"} takes a vector of logged probabilities (neagtive values)
#'   and returns its sum.
#'
#' @param x a numeric vector of logged probabilities.
#' @return returns a single numeric value representing the logged sum of the
#'   values in the input vector.
#' @details This is a simple compiled function that exponentiates the values
#' in the input vector, finds their sum, and returns the log of that value.
#' @author Shaun P. Wilkinson
#'
logsum <- function(x) {
    .Call('aphid_logsum', PACKAGE = 'aphid', x)
}

#' Find the position of the maximum value.
#'
#' Returns the position (index) of the maximum value in a numeric or integer vector,
#'   with ties broken at random.
#'
#' @param x a numeric or integer vector.
#' @param start integer indicating the index of the first value
#'   of the vector. Defaults to 1 (consistent the indexing system used by R,
#'   as opposed to that used by C and C++ in which the first value is given
#'   an index of 0).
#' @return returns an integer representing the position (index) of the maximum
#'   value in the input vector.
#' @details This is a simple compiled function similar to which.max{base} but
#'   with random breaking of ties. Unlike which.max{base}, logical vectors are
#'   not accepted.
#' @author Shaun P. Wilkinson
#'
whichmax <- function(x, start = 1L) {
    .Call('aphid_whichmax', PACKAGE = 'aphid', x, start)
}

.probDNA <- function(x, probs) {
    .Call('aphid_probDNA', PACKAGE = 'aphid', x, probs)
}

.probAA <- function(x, probs) {
    .Call('aphid_probAA', PACKAGE = 'aphid', x, probs)
}

.ViterbiD <- function(x, y, type, d, e, S, windowspace, offset = 0) {
    .Call('aphid_ViterbiD', PACKAGE = 'aphid', x, y, type, d, e, S, windowspace, offset)
}

.ViterbiH <- function(y, A, E, DNA = FALSE, AA = FALSE) {
    .Call('aphid_ViterbiH', PACKAGE = 'aphid', y, A, E, DNA, AA)
}

.ViterbiP <- function(y, A, E, qe, qey, type, windowspace, offset = 0, DI = FALSE, ID = FALSE, DNA = FALSE, AA = FALSE) {
    .Call('aphid_ViterbiP', PACKAGE = 'aphid', y, A, E, qe, qey, type, windowspace, offset, DI, ID, DNA, AA)
}

.ViterbiPP <- function(Ax, Ay, Ex, Ey, qe, type, windowspace, offset = 0) {
    .Call('aphid_ViterbiPP', PACKAGE = 'aphid', Ax, Ay, Ex, Ey, qe, type, windowspace, offset)
}

.forwardH <- function(y, A, E, DNA = FALSE, AA = FALSE) {
    .Call('aphid_forwardH', PACKAGE = 'aphid', y, A, E, DNA, AA)
}

.forwardP <- function(y, A, E, qe, qey, type, windowspace, DI = FALSE, ID = FALSE, DNA = FALSE, AA = FALSE) {
    .Call('aphid_forwardP', PACKAGE = 'aphid', y, A, E, qe, qey, type, windowspace, DI, ID, DNA, AA)
}

.backwardH <- function(y, A, E, DNA = FALSE, AA = FALSE) {
    .Call('aphid_backwardH', PACKAGE = 'aphid', y, A, E, DNA, AA)
}

.backwardP <- function(y, A, E, qe, qey, type, windowspace, DI = FALSE, ID = FALSE, DNA = FALSE, AA = FALSE) {
    .Call('aphid_backwardP', PACKAGE = 'aphid', y, A, E, qe, qey, type, windowspace, DI, ID, DNA, AA)
}

.kcountDNA <- function(x, k = 5L) {
    .Call('aphid_kcountDNA', PACKAGE = 'aphid', x, k)
}

.kdist <- function(x, from, to, seqlengths, k) {
    .Call('aphid_kdist', PACKAGE = 'aphid', x, from, to, seqlengths, k)
}

.map <- function(ecs, notgaps, pseudocounts, seqweights, qe, lambda = 0) {
    .Call('aphid_map', PACKAGE = 'aphid', ecs, notgaps, pseudocounts, seqweights, qe, lambda)
}

.acount <- function(x, arity) {
    .Call('aphid_acount', PACKAGE = 'aphid', x, arity)
}

.ecount <- function(states, statearity, residues, resarity) {
    .Call('aphid_ecount', PACKAGE = 'aphid', states, statearity, residues, resarity)
}

.atab <- function(x, seqweights) {
    .Call('aphid_atab', PACKAGE = 'aphid', x, seqweights)
}

